---
title: Solidity编程基础（三）
date: 2022-03-08 14:33:06
categories: 区块链
tags: Solidity
---
@[TOC](Solidity编程基础三)
# 概要
本章将进行太坊虚拟机EVM的介绍、Solidity的三种数据存储位置的 区别以及不同情况下跨区域数据赋值的gas成本分析与利用等内容。

在前文讲变量、函数时，我们讲过EVM提供了四种数据结构来存储数据：Storage、Calldata、Stack、Memory。


<!--more-->  

# 以太坊虚拟机 EVM
EVM是以太坊用于提供Solidity合约运行的轻量级操作系统，其运行在以太坊的每个节点上。EVM的架构基于栈机器模型，这意味着 其指令集是基于栈而非寄存器来运作的，所以在开始探讨Solidity的数据存储之前，我想先介绍下以太坊虚拟机 的一些相关内容，以便更容易理解后续的部分。

EVM的内部结构大致如下图所示：
![在这里插入图片描述](https://img-blog.csdnimg.cn/7f89c8901ab84ed1bc29301b3bd086d1.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAQkJpbkNoaW5h,size_20,color_FFFFFF,t_70,g_se,x_16)
在EVM中指令的执行流程如下：当一个交易触发智能合约代码的执行时， 就会实例化一个EVM，EVM的ROM载入了要调用的合约代码。程序计数器 被清零，存储从合约账号对应的部分载入，内存清零，设置区块和环境 变量，然后代码开始执行。

# 数据位置
Storage、Calldata、Stack、Memory。

## storage/存储
 - 存储中的数据是永久存在的
 - 存储是一个key/value库 存储中的数据写入区块链，因此会修改状态，这也是存储使用成本高的原因
 - 当清零一个存储槽时，会返还一定数量的gas
 - 存储按256位的槽位分配，即使没有完全使用一个槽位，也需要支付其开销

## memory/内存
 - 内存是一个字节数组，槽大小位256位（32字节） 
 - 数据仅在函数执行期间存在，执行完毕后就被销毁 
 - 读或写一个内存槽都会消耗gas

## calldata/调用数据
 - 调用数据是不可修改、非持久化的区域，用来保存函数参数，其行为类似于内存
 -  外部函数的参数必须使用calldata，但是也可用于其他变量
 - 调用数据避免了数据拷贝，并确保数据不被修改 
 - 函数也可以返回使用calldata声明的数组和结果，但是不可能分配这些类型

## Stack 栈
EVM为了导入变量和以太坊的机器/汇编指令代码，维护了一个栈，本质是EVM的内存工作环境，有1024级神，如果存储超过1024级数据，便会触发异常。


总结：

 - 默认的函数参数（包括返回的参数）是memory
 - 默认的局部变量时storage
 - 默认的状态变量（合约声明中的公有变量）是storage

# 数据赋值成本
 - 在存储和内存（或调用数据）间的赋值将创建一个新的独立拷贝 
 - 内存之间的赋值仅创建引用，这意味着对一个内存变量的修改会同时反应在其他引用相同数据的内存变量上
 -  从存储到局部存储变量的赋值，实际上只会给一个引用
 -  所有其他赋值通常导致产生新的数据拷贝。例如赋值给状态变量 或位于存储的结构类型的局部变量成员时，即使局部变量只是一个引用，也会产生新的数据拷贝

memory存储位置同普通程序的内存一致，即时分配，即时使用，而在区块链上，由于底层实现了图灵完备，会有非常多的状态需要永久记录下来，因此需要使用storage类型存储，一旦使用了该类型，数据将永远存在链上，基于程序的上下文，大多数时候默认选择storage，也可以通过指定关键字storage和memory进行修改。

